<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.54">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>DSAN-5000: Project</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./assets/gu-logo.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">DSAN-5000: Project</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./index.html" aria-current="page"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./report/report.html"> 
<span class="menu-text">Report</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about_authors/about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-technical-details" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Technical details</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-technical-details">    
        <li>
    <a class="dropdown-item" href="./technical-details/data-collection/main.html">
 <span class="dropdown-text">Data-collection</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./technical-details/data-cleaning/main.html">
 <span class="dropdown-text">Data-cleaning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./technical-details/eda/main.html">
 <span class="dropdown-text">Exploratory Data Analysis</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./technical-details/unsupervised-learning/main.html">
 <span class="dropdown-text">Unsupervised Learning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./technical-details/supervised-learning/main.html">
 <span class="dropdown-text">Supervised Learning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./technical-details/progress-log.html">
 <span class="dropdown-text">Progress Log</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./technical-details/llm-usage-log.html">
 <span class="dropdown-text">LLM usage Log</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#summary-of-topic" id="toc-summary-of-topic" class="nav-link active" data-scroll-target="#summary-of-topic">Summary of Topic</a></li>
  <li><a href="#significance" id="toc-significance" class="nav-link" data-scroll-target="#significance">Significance</a></li>
  <li><a href="#questions-to-explore" id="toc-questions-to-explore" class="nav-link" data-scroll-target="#questions-to-explore">Questions to Explore</a></li>
  <li><a href="#literature-review" id="toc-literature-review" class="nav-link" data-scroll-target="#literature-review">Literature review</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">




<h1 style="text-align:center;">
Food for Thought: A Joint Investigating of the Socioeconomic Food Gap and Yelp Ratings in the DC area
</h1>
<h3 style="text-align:center;" class="anchored">
<img src="assets/yelp.png" class="img-fluid" width="200"> <img src="assets/map.png" class="img-fluid" width="200">
</h3>
<section id="summary-of-topic" class="level3">
<h3 class="anchored" data-anchor-id="summary-of-topic">Summary of Topic</h3>
<p>Washington, DC is a vibrant and diverse city, home to everyone from dignitaries to presidents, making it a true hub for international cuisine. From upscale fine dining establishments to hidden gems and hole-in-the-wall eateries, DC offers a culinary experience for every palate. This project explores the restaurant landscape of DC, investigating the features that make its dining scene unique and analyzing how socioeconomic factors influence Yelp ratings.</p>
</section>
<section id="significance" class="level3">
<h3 class="anchored" data-anchor-id="significance">Significance</h3>
<p>The most significant impact of this study could be its potential to help small, independently-owned businesses. Launching and maintaining a successful restaurant is notoriously challenging, and in a dynamic, ever-changing city like Washington, DC, the difficulties can be even greater. By analyzing patterns and identifying the key features that contribute to success, this research could offer valuable insights to restaurateurs. These findings might help small business owners achieve stability and profitability without compromising the quality of their food. Supporting these businesses not only fosters economic growth but also preserves the cultural and culinary diversity that makes DC’s food scene unique.</p>
</section>
<section id="questions-to-explore" class="level3">
<h3 class="anchored" data-anchor-id="questions-to-explore">Questions to Explore</h3>
<ol type="1">
<li>What factors are most important to a high Yelp Rating score?</li>
<li>Do better neighborhoods (measured by median income) generally have better restaurants (measured by Yelp ratings)?</li>
<li>Are certain types of restaurants more likely to be rated higher on yelp?</li>
<li>Does price of the restaurant factor into Yelp rating?</li>
<li>Is it possible to predict the Yelp rating of a restaurant based on its features?</li>
</ol>
</section>
<section id="literature-review" class="level3">
<h3 class="anchored" data-anchor-id="literature-review">Literature review</h3>
<p>As more businesses have begun interacting with online marketing, Yelp and similar reviewing sites have grown in popularity. This phenomenom has lead many to attempt to understand the ratings and reviews habits of consumers and to go so far as predicting which establishments will receive higher ratings.</p>
<p>In “Characterizing Non-Chain Restaurants’ Yelp Star-Ratings: Generalizable Findings from a Representative Sample of Yelp Reviews” Keller and Kostromitina attempt to investigate whether Yelp star ratings are characterized by different criteria, ie is there a particular reason that restaurants are given the particular rating and is there a consistent pattern across these restaurants. To achieve this goal, the authors took data from Yelp.com that totaled 54,000 reviews on restaurants that were categorized as non-chain restaurants. The dataset includes the Yelp rating of the restaurant, the reviews, and other metadata about the specific restaurant. They then employed multiple correspondance analysis (MCA) to investigate the underlying structures and patterns of the data. They found that the service, food quality, and the overall environment of a restaurant does, in fact, matter for the Yelp rating of a particular restaurant. Further, they found that this effect was varied across the different star ratings for Yelp. For the 1 to 2 star range, the authors found that the most important factor contributing to the rating was the wait time for food. For the 3 star establishments, the most important factor was the quality of the food and for the 4 to 5 star rating range the most important factor was the ability to cultivate a positive customer experience, which is a combination of the wait time, the food quality, and the service.</p>
<p>In “Yelp Review Rating Prediction: Machine Learning and Deep Learning Models”, Liu attempts to predict the yelp rating score based on the cumulative sentiment of the Yelp reviews for restaurants. The author begins by utilizing the Yelp Open dataset, which provides data on the businesses that are listed on the website. This dataset is subsetted to include only restaurants, which leads to 63,944 review observations. The author notes that the dataset is highly skewed due to the restaurants with more reviews, generally having a higher rating (in the 4-5 star yelp rating range). From these reviews, two vectorizer techniques are employed, TF-IDF and a count vectorizer. The author determines that the TF-IDf is found to be a better vectorizer for the review text based on evaluation metrics. From here, four machine learning models are trained and testing on the TF-IDF data: Naive Bayes, logistic regression, random forest, and linear support vector machine. In addition, four transformer models are trained and tested on the text data: BERT, DistillBERT, XLNet, and RoBERTa. Evaluation metrics including accuracy, F1-score, and confusion matrics are utilized to evaluate all of the models. The end result is that the model are able to partially reliably predict the Yelp rating score. Particularly, there was foudn to be a 64% accuracy score for prediction using the Machine Learning techniques and a 70% accuracy score for rating prediction using the transformer techniques.</p>
<p>The study “Applications of Machine Learning to Predict Yelp Ratings” by Kyle Carbon, Kacyn Jujii, and Parasanth Veerina investigates factors influencing Yelp ratings and business performance, utilizing data from Phoenix, AZ. The authors employ K-means clustering to evaluate the role of location by measuring distances to shopping malls and popular landmarks. They conduct statistical tests to identify significant features and implement machine learning models, including logistic regression, SVM, random forests, and decision trees, achieving an average accuracy of 45%. The findings highlight that while factors like location, price range, and availability of take-out services significantly impact ratings, the most critical determinant is review sentiment. Notably, different features were found to influence ratings for specific business types; for example, speed is prioritized for fast-food establishments, whereas quality is emphasized for upscale restaurants. Sentiment classification emerged as the most predictive feature, indicating that customer review sentiment is the strongest indicator of business ratings on Yelp.</p>
<p>On the flip side of this and acting from a more critical persepctive, some have tried to understand whether these online ratings actually hold any weight. They have investigated if predicting the online rating system will actually lead to real-world pay off.</p>
<p>“Analysis of Yelp Reviews” examines the role of reviews and ratings in predicting business success, focusing specifically on restaurants in college towns. The authors highlight the unique characteristics of college-town restaurants, noting their relatively short average lifespan of around four years. The study analyzes data from 20 different college campuses over a 7-year period and employs mathematical modeling, including differential equations, to understand Yelp reviews. Key findings include the observation that the relationship between the number of reviews and ratings follows a power-law distribution. Additionally, restaurants with a higher number of reviews tend to cluster geographically. The researchers also analyze the running average rating of all restaurants in a college town over time, alongside detailed case studies of the most-reviewed restaurant in each town. The study reveals that initial reviews can significantly impact a restaurant’s trajectory, but these effects stabilize as more reviews accumulate. They attribute some trends to college students’ unique dining habits. For example, pizza restaurants consistently rank highly and are the most common across towns, while university-sponsored dining establishments often receive lower ratings. Interestingly, the types of top-rated ethnic restaurants vary between towns, reflecting local cultural preferences.</p>
<p>In another branch of online review research, there has emerged literature that examines the topic from an economical standpoint. They look at the larger picture of determining how restaurants impact the local economy. By understanding how Yelp reviews impact an establishment and how that establishment impacts the economy overall, they are, by proxy, examining the role of online reviews on the local economy.</p>
<p>Kuang (2017) attempted to look at whether the quality of consumption anemities (ie restaurants) have a significant impact on the surronding local economy. In the paper “Does Quality Matter in Local Consumption Amenities? An Empirical Investigation with Yelp”, the author utilized housing data from the D.C. Office of Tax and Revenue Computer Assisted Mass Appraisal Database coupled with restaurant data collected from Yelp.com to investigate the effect on housing prices of quality restaurants. The quality of a restaurant was measured by consumer ratings and price estimates from Yelp. To investigate this guiding question, Kuang employed econometric techniques including regression analysis, neighborhood-year fixed effects, and difference-in-difference (DID) estimation. The DID estimation was done before and after the popularization of Yelp in the DC area across time periods and restaurant measures. With the DID, the author wanted to determine whether information on restaurant amenitieis matters and particularly what type of information matters. In addition, robustness checks and falsification were employed to see if the results were robust to a restricted housing sample, a different choice of radius, including other local attributes, and utilizing a smaller timeframe. The end result was that highly rated restaurants do, in fact, attract customers, which generates revenues, and positively impacts the local economy. Further, that Yelp reviews do act as a reliable signal of quality for a restaurant. They conclude that there is a positive effect on housing prices due to both the quantity and quality of restaurants in a given area, but caution this do not imply causation and building quality anemities will not increase housing prices.</p>
<p>In a 2019 article, Luo and Xu delve into the importance of Yelp reviews and their role in the restaurant industry, highlighting the challenges restaurants face, such as rising food prices, high labor costs, and a failure rate exceeding 60% within the first three years. It underscores the economic significance of the restaurant industry, noting its contribution to local economic growth and employment rates. The article also emphasizes the critical role of online reviews, citing that 94% of people choose a restaurant based on reviews. The study focuses on two key aspects for machine learning models: dining features of restaurants and customer reviews. It employs models like Naive Bayes and Naive Bayes combined with Support Vector Machines (SVM), with SVM achieving the highest F1 accuracy at 71%. The research identifies four essential features influencing customer satisfaction: taste, experience, value, and location. It observes that with an increasing number of reviews, the quality of food emerges as the most important factor for customers, followed by service. Negative reviews are primarily linked to concerns about price or value. This work explores the intersection of natural language processing (NLP) and machine learning in analyzing Yelp reviews to predict business success, offering valuable insights into customer preferences and the factors driving restaurant performance</p>
<p><strong>References</strong>:</p>
<ul>
<li>Characterizing Non-Chain Restaurants’ Yelp Star-Ratings: Generalizable Findings from a Representative Sample of Yelp Reviews
<ul>
<li>Keller, D., &amp; Kostromitina, M. (2020). Characterizing non-chain restaurants’ Yelp star-ratings: Generalizable findings from a representative sample of Yelp reviews. International Journal of Hospitality Management, 86, 102440.</li>
</ul></li>
<li>Yelp Review Rating Prediction: Machine Learning and Deep Learning Models
<ul>
<li>Liu, Z. (2020). Yelp review rating prediction: Machine learning and deep learning models. arXiv preprint arXiv:2012.06690.</li>
</ul></li>
<li>Applications of Machine Learning to Predict Yelp Ratings
<ul>
<li>Carbon, K., Fujii, K., &amp; Veerina, P. (2014). Applications of machine learning to predict Yelp ratings. 2014.</li>
</ul></li>
<li>Analysis of Yelp Reviews
<ul>
<li>Hajas, P., Gutierrez, L., &amp; Krishnamoorthy, M. S. (2014). Analysis of yelp reviews. arXiv preprint arXiv:1407.1443.</li>
</ul></li>
<li>Does Quality Matter in Local Consumption Amenities? An Empirical Investigation with Yelp
<ul>
<li>Kuang, C. (2017). Does quality matter in local consumption amenities? An empirical investigation with Yelp. Journal of Urban Economics, 100, 1-18.</li>
</ul></li>
<li>Predicting the Helpfulness of Online Restaurant Reviews Using Different Machine Learning Algorithms: A Case Study of Yelp
<ul>
<li>Luo, Y., &amp; Xu, X. (2019). Predicting the helpfulness of online restaurant reviews using different machine learning algorithms: A case study of yelp. Sustainability, 11(19), 5254.</li>
</ul></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>